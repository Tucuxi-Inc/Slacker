# SlackSassin Complete Implementation Plan
## Database, Zapier Workflows, UI Mockups & Integration

### Executive Summary

SlackSassin transforms your existing Slacker macOS app (currently an Ollama-powered local AI chat) into a comprehensive Slack assistant that processes incoming Slack messages via webhooks, generates AI responses using local Ollama, and provides a streamlined workflow for managing and sending responses back to Slack.

**Updated Architecture Integration:**
- **Primary Interface**: SlackOffView (new main view for Slack message processing)
- **Secondary Interface**: ChatView (existing traditional chat, now secondary)
- **NGrok Tunnel**: Static URL `https://relaxing-sensibly-ghost.ngrok-free.app/` → `localhost:8080`
- **Webhook Endpoint**: `/zapier-webhook` for message reception
- **Navigation**: Seamless flow between reactive message processing and interactive chat

**Core Architecture:**
- **Zapier** collects @mentions and keywords every 15 minutes
- **Ngrok tunnel** (`https://relaxing-sensibly-ghost.ngrok-free.app/`) delivers batched messages to your macOS app
- **Local Ollama** generates AI responses privately
- **Review interface** lets users approve, edit, or reject responses
- **Auto-rules engine** learns patterns and handles routine responses
- **Analytics dashboard** tracks efficiency and optimization opportunities

---

## Part 0: Application Structure Integration

### 0.1 Updated Navigation Flow
```
SlackerApp
├── SlackOffView (NEW PRIMARY INTERFACE)
│   ├── Webhook Server Status (localhost:8080)
│   ├── NGrok Tunnel Status (relaxing-sensibly-ghost.ngrok-free.app)
│   ├── Slack Message Feed/Queue Management
│   ├── AI Response Generation & Approval Workflow
│   ├── Action Buttons (Copy, Edit, Send to Slack, Dismiss)
│   ├── Quick Analytics Summary
│   └── "Chat with SlackSassin" Navigation Button → ChatView
└── ChatView (EXISTING - SECONDARY INTERFACE)
    ├── Traditional AI Chat Interface (existing functionality)
    ├── Context Import from SlackOff (when "Edit in Chat" used)
    └── "Back to SlackOff" Navigation Button
```

### 0.2 Webhook Infrastructure Specification
- **NGrok Static URL**: `https://relaxing-sensibly-ghost.ngrok-free.app/`
- **Local Command**: `ngrok http --url=relaxing-sensibly-ghost.ngrok-free.app 8080`
- **Webhook Endpoint**: `POST /zapier-webhook`
- **Health Check**: `GET /health`
- **Status Endpoint**: `GET /status`

### 0.3 Development Phases Overview
1. **Phase 1 (Week 1-2)**: Foundation - Database, HTTP server, basic webhook reception
2. **Phase 2 (Week 3-4)**: Core UI - SlackOffView, message display, basic actions
3. **Phase 3 (Week 5-6)**: AI Integration - Ollama processing, response management
4. **Phase 4 (Week 7-8)**: Advanced Features - Auto-rules, analytics, polish

---

## Part 1: Database Architecture & Setup Scripts

### 1.1 Complete Database Schema

```sql
-- SlackSassin Database Schema
-- SQLite database for local storage

-- Core Messages Table
CREATE TABLE IF NOT EXISTS messages (
    id TEXT PRIMARY KEY,
    slack_message_id TEXT UNIQUE NOT NULL,
    slack_user_id TEXT NOT NULL,
    slack_user_name TEXT NOT NULL,
    slack_channel_id TEXT NOT NULL,
    slack_channel_name TEXT NOT NULL,
    message_text TEXT NOT NULL,
    message_timestamp DATETIME NOT NULL,
    thread_timestamp TEXT, -- For threaded replies
    permalink TEXT,
    matched_keywords TEXT, -- JSON array of keywords that triggered collection
    message_type TEXT DEFAULT 'mention', -- 'mention', 'keyword', 'dm'
    status TEXT DEFAULT 'pending', -- 'pending', 'processed', 'archived', 'ignored'
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- AI Generated Responses Table
CREATE TABLE IF NOT EXISTS ai_responses (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    message_id TEXT NOT NULL REFERENCES messages(id) ON DELETE CASCADE,
    original_response TEXT NOT NULL,
    edited_response TEXT, -- User's edited version
    confidence_score REAL DEFAULT 0.0,
    model_used TEXT DEFAULT 'ollama',
    generation_time_ms INTEGER,
    status TEXT DEFAULT 'pending', -- 'pending', 'approved', 'edited', 'rejected', 'sent', 'failed'
    auto_rule_id TEXT, -- If generated by auto-rule
    user_rating INTEGER, -- 1-5 stars for learning
    sent_at DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Auto-Response Rules Table
CREATE TABLE IF NOT EXISTS auto_rules (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    trigger_keywords TEXT NOT NULL, -- JSON array
    trigger_channels TEXT, -- JSON array, empty = all channels
    trigger_users TEXT, -- JSON array, empty = all users
    response_template TEXT NOT NULL,
    confidence_threshold REAL DEFAULT 0.7,
    auto_send_enabled BOOLEAN DEFAULT FALSE,
    require_approval BOOLEAN DEFAULT TRUE,
    is_active BOOLEAN DEFAULT TRUE,
    usage_count INTEGER DEFAULT 0,
    success_rate REAL DEFAULT 0.0,
    last_used_at DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Response Templates Table
CREATE TABLE IF NOT EXISTS response_templates (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    category TEXT DEFAULT 'general',
    template_text TEXT NOT NULL,
    usage_count INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Analytics & Metrics Table
CREATE TABLE IF NOT EXISTS analytics_events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    event_type TEXT NOT NULL, -- 'message_received', 'response_generated', 'response_sent', 'rule_triggered'
    message_id TEXT,
    response_id INTEGER,
    rule_id TEXT,
    event_data TEXT, -- JSON for additional data
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- User Settings Table
CREATE TABLE IF NOT EXISTS user_settings (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    data_type TEXT DEFAULT 'string', -- 'string', 'number', 'boolean', 'json'
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Workspace Configuration Table
CREATE TABLE IF NOT EXISTS workspaces (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    team_id TEXT UNIQUE NOT NULL,
    bot_token TEXT, -- Encrypted
    webhook_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    last_sync_at DATETIME,
    message_count INTEGER DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Create Indexes for Performance
CREATE INDEX IF NOT EXISTS idx_messages_status ON messages(status);
CREATE INDEX IF NOT EXISTS idx_messages_timestamp ON messages(message_timestamp);
CREATE INDEX IF NOT EXISTS idx_messages_channel ON messages(slack_channel_id);
CREATE INDEX IF NOT EXISTS idx_responses_status ON ai_responses(status);
CREATE INDEX IF NOT EXISTS idx_responses_message ON ai_responses(message_id);
CREATE INDEX IF NOT EXISTS idx_analytics_type ON analytics_events(event_type);
CREATE INDEX IF NOT EXISTS idx_analytics_date ON analytics_events(created_at);

-- Create Triggers for Updated Timestamps
CREATE TRIGGER IF NOT EXISTS update_messages_timestamp 
    AFTER UPDATE ON messages
    BEGIN
        UPDATE messages SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
    END;

CREATE TRIGGER IF NOT EXISTS update_responses_timestamp 
    AFTER UPDATE ON ai_responses
    BEGIN
        UPDATE ai_responses SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
    END;

CREATE TRIGGER IF NOT EXISTS update_rules_timestamp 
    AFTER UPDATE ON auto_rules
    BEGIN
        UPDATE auto_rules SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
    END;
```

### 1.2 Database Initialization Script

```swift
// DatabaseManager.swift - Add to your existing macOS app

import Foundation
import SQLite3

class SlackSassinDatabase {
    private var db: OpaquePointer?
    private let dbPath: String
    
    init() {
        // Store database in Application Support directory
        let fileManager = FileManager.default
        let appSupport = fileManager.urls(for: .applicationSupportDirectory, 
                                        in: .userDomainMask).first!
        let appDirectory = appSupport.appendingPathComponent("SlackSassin")
        
        try? fileManager.createDirectory(at: appDirectory, 
                                       withIntermediateDirectories: true)
        
        dbPath = appDirectory.appendingPathComponent("slacksassin.db").path
        
        openDatabase()
        createTables()
        insertDefaultSettings()
    }
    
    private func openDatabase() {
        if sqlite3_open(dbPath, &db) != SQLITE_OK {
            print("Unable to open database at \(dbPath)")
        } else {
            print("SlackSassin database opened successfully")
        }
    }
    
    private func createTables() {
        let createTablesSQL = """
        -- Insert the complete SQL schema from above here --
        """
        
        if sqlite3_exec(db, createTablesSQL, nil, nil, nil) != SQLITE_OK {
            let errmsg = String(cString: sqlite3_errmsg(db)!)
            print("Error creating tables: \(errmsg)")
        }
    }
    
    private func insertDefaultSettings() {
        let defaultSettings = [
            ("processing_interval", "15", "number"),
            ("confidence_threshold", "0.7", "number"),
            ("auto_send_enabled", "false", "boolean"),
            ("notification_enabled", "true", "boolean"),
            ("max_response_length", "280", "number"),
            ("ollama_model", "llama2", "string"),
            ("zapier_webhook_url", "", "string"),
            ("ngrok_domain", "", "string")
        ]
        
        for (key, value, type) in defaultSettings {
            insertOrUpdateSetting(key: key, value: value, dataType: type)
        }
    }
    
    // MARK: - Message Operations
    
    func insertMessage(_ message: SlackMessage) -> Bool {
        let sql = """
            INSERT OR REPLACE INTO messages 
            (id, slack_message_id, slack_user_id, slack_user_name, 
             slack_channel_id, slack_channel_name, message_text, 
             message_timestamp, thread_timestamp, permalink, matched_keywords, message_type)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        
        var statement: OpaquePointer?
        
        if sqlite3_prepare_v2(db, sql, -1, &statement, nil) == SQLITE_OK {
            sqlite3_bind_text(statement, 1, message.id, -1, nil)
            sqlite3_bind_text(statement, 2, message.slackMessageId, -1, nil)
            sqlite3_bind_text(statement, 3, message.slackUserId, -1, nil)
            sqlite3_bind_text(statement, 4, message.slackUserName, -1, nil)
            sqlite3_bind_text(statement, 5, message.slackChannelId, -1, nil)
            sqlite3_bind_text(statement, 6, message.slackChannelName, -1, nil)
            sqlite3_bind_text(statement, 7, message.messageText, -1, nil)
            sqlite3_bind_text(statement, 8, message.messageTimestamp.iso8601, -1, nil)
            sqlite3_bind_text(statement, 9, message.threadTimestamp, -1, nil)
            sqlite3_bind_text(statement, 10, message.permalink, -1, nil)
            sqlite3_bind_text(statement, 11, message.matchedKeywords.jsonString, -1, nil)
            sqlite3_bind_text(statement, 12, message.messageType.rawValue, -1, nil)
            
            if sqlite3_step(statement) == SQLITE_DONE {
                sqlite3_finalize(statement)
                logAnalyticsEvent(type: "message_received", messageId: message.id)
                return true
            }
        }
        
        sqlite3_finalize(statement)
        return false
    }
    
    func getPendingMessages() -> [SlackMessage] {
        let sql = "SELECT * FROM messages WHERE status = 'pending' ORDER BY message_timestamp DESC"
        var messages: [SlackMessage] = []
        var statement: OpaquePointer?
        
        if sqlite3_prepare_v2(db, sql, -1, &statement, nil) == SQLITE_OK {
            while sqlite3_step(statement) == SQLITE_ROW {
                if let message = parseMessageFromRow(statement) {
                    messages.append(message)
                }
            }
        }
        
        sqlite3_finalize(statement)
        return messages
    }
    
    // MARK: - AI Response Operations
    
    func insertAIResponse(_ response: AIResponse) -> Bool {
        let sql = """
            INSERT INTO ai_responses 
            (message_id, original_response, confidence_score, model_used, 
             generation_time_ms, auto_rule_id)
            VALUES (?, ?, ?, ?, ?, ?)
        """
        
        var statement: OpaquePointer?
        
        if sqlite3_prepare_v2(db, sql, -1, &statement, nil) == SQLITE_OK {
            sqlite3_bind_text(statement, 1, response.messageId, -1, nil)
            sqlite3_bind_text(statement, 2, response.originalResponse, -1, nil)
            sqlite3_bind_double(statement, 3, response.confidenceScore)
            sqlite3_bind_text(statement, 4, response.modelUsed, -1, nil)
            sqlite3_bind_int(statement, 5, Int32(response.generationTimeMs))
            sqlite3_bind_text(statement, 6, response.autoRuleId, -1, nil)
            
            if sqlite3_step(statement) == SQLITE_DONE {
                sqlite3_finalize(statement)
                logAnalyticsEvent(type: "response_generated", messageId: response.messageId)
                return true
            }
        }
        
        sqlite3_finalize(statement)
        return false
    }
    
    // MARK: - Auto Rules Operations
    
    func getActiveAutoRules() -> [AutoRule] {
        let sql = "SELECT * FROM auto_rules WHERE is_active = 1 ORDER BY usage_count DESC"
        var rules: [AutoRule] = []
        var statement: OpaquePointer?
        
        if sqlite3_prepare_v2(db, sql, -1, &statement, nil) == SQLITE_OK {
            while sqlite3_step(statement) == SQLITE_ROW {
                if let rule = parseAutoRuleFromRow(statement) {
                    rules.append(rule)
                }
            }
        }
        
        sqlite3_finalize(statement)
        return rules
    }
    
    // MARK: - Analytics Operations
    
    func logAnalyticsEvent(type: String, messageId: String? = nil, responseId: Int? = nil, ruleId: String? = nil, eventData: [String: Any]? = nil) {
        let sql = """
            INSERT INTO analytics_events 
            (event_type, message_id, response_id, rule_id, event_data)
            VALUES (?, ?, ?, ?, ?)
        """
        
        var statement: OpaquePointer?
        
        if sqlite3_prepare_v2(db, sql, -1, &statement, nil) == SQLITE_OK {
            sqlite3_bind_text(statement, 1, type, -1, nil)
            sqlite3_bind_text(statement, 2, messageId, -1, nil)
            if let responseId = responseId {
                sqlite3_bind_int(statement, 3, Int32(responseId))
            }
            sqlite3_bind_text(statement, 4, ruleId, -1, nil)
            if let eventData = eventData,
               let jsonData = try? JSONSerialization.data(withJSONObject: eventData),
               let jsonString = String(data: jsonData, encoding: .utf8) {
                sqlite3_bind_text(statement, 5, jsonString, -1, nil)
            }
            
            sqlite3_step(statement)
        }
        
        sqlite3_finalize(statement)
    }
    
    func getAnalyticsMetrics(days: Int = 30) -> AnalyticsMetrics {
        let cutoffDate = Calendar.current.date(byAdding: .day, value: -days, to: Date())!
        let sql = """
            SELECT 
                COUNT(CASE WHEN event_type = 'message_received' THEN 1 END) as messages_received,
                COUNT(CASE WHEN event_type = 'response_generated' THEN 1 END) as responses_generated,
                COUNT(CASE WHEN event_type = 'response_sent' THEN 1 END) as responses_sent,
                COUNT(CASE WHEN event_type = 'rule_triggered' THEN 1 END) as rules_triggered
            FROM analytics_events 
            WHERE created_at >= ?
        """
        
        var statement: OpaquePointer?
        var metrics = AnalyticsMetrics()
        
        if sqlite3_prepare_v2(db, sql, -1, &statement, nil) == SQLITE_OK {
            sqlite3_bind_text(statement, 1, cutoffDate.iso8601, -1, nil)
            
            if sqlite3_step(statement) == SQLITE_ROW {
                metrics.messagesReceived = Int(sqlite3_column_int(statement, 0))
                metrics.responsesGenerated = Int(sqlite3_column_int(statement, 1))
                metrics.responsesSent = Int(sqlite3_column_int(statement, 2))
                metrics.rulesTriggered = Int(sqlite3_column_int(statement, 3))
            }
        }
        
        sqlite3_finalize(statement)
        return metrics
    }
    
    // MARK: - Settings Operations
    
    func insertOrUpdateSetting(key: String, value: String, dataType: String) {
        let sql = """
            INSERT OR REPLACE INTO user_settings (key, value, data_type, updated_at)
            VALUES (?, ?, ?, CURRENT_TIMESTAMP)
        """
        
        var statement: OpaquePointer?
        
        if sqlite3_prepare_v2(db, sql, -1, &statement, nil) == SQLITE_OK {
            sqlite3_bind_text(statement, 1, key, -1, nil)
            sqlite3_bind_text(statement, 2, value, -1, nil)
            sqlite3_bind_text(statement, 3, dataType, -1, nil)
            sqlite3_step(statement)
        }
        
        sqlite3_finalize(statement)
    }
    
    func getSetting(key: String) -> String? {
        let sql = "SELECT value FROM user_settings WHERE key = ?"
        var statement: OpaquePointer?
        var result: String?
        
        if sqlite3_prepare_v2(db, sql, -1, &statement, nil) == SQLITE_OK {
            sqlite3_bind_text(statement, 1, key, -1, nil)
            
            if sqlite3_step(statement) == SQLITE_ROW {
                result = String(cString: sqlite3_column_text(statement, 0))
            }
        }
        
        sqlite3_finalize(statement)
        return result
    }
    
    deinit {
        sqlite3_close(db)
    }
}

// MARK: - Data Models

// MARK: - Core Data Models (Aligned with Slacker Architecture)

struct SlackMessage {
    let id: String // UUID for internal tracking
    let slackMessageId: String
    let slackUserId: String
    let slackUserName: String
    let slackChannelId: String
    let slackChannelName: String
    let messageText: String
    let messageTimestamp: Date
    let threadTimestamp: String? // thread_ts from Slack
    let permalink: String?
    let matchedKeywords: [String]
    let messageType: MessageType
    var status: MessageStatus = .pending
    
    // Processing metadata
    let receivedAt: Date = Date.now
    var processedAt: Date?
    var sentAt: Date?
    var error: String?
    
    enum MessageType: String, CaseIterable {
        case mention, keyword, dm
    }
    
    enum MessageStatus: String, CaseIterable {
        case pending, processing, completed, sent, error, dismissed
    }
    
    // Initialize from Zapier webhook payload
    init(from zapierPayload: ZapierPayload) {
        self.id = UUID().uuidString
        self.slackMessageId = zapierPayload.timestamp
        self.slackUserId = zapierPayload.userId
        self.slackUserName = zapierPayload.userName ?? "Unknown User"
        self.slackChannelId = zapierPayload.channelId
        self.slackChannelName = zapierPayload.channelName ?? "Unknown Channel"
        self.messageText = zapierPayload.text
        self.messageTimestamp = Date() // Convert from zapierPayload.timestamp
        self.threadTimestamp = zapierPayload.threadTS
        self.permalink = nil // Can be added later if needed
        self.matchedKeywords = ["mention"] // Default, can be enhanced
        self.messageType = zapierPayload.channelId.starts(with: "D") ? .dm : .mention
    }
}

// Webhook payload structure for Zapier integration
struct ZapierPayload: Codable {
    let text: String
    let channelId: String
    let channelName: String?
    let userId: String
    let userName: String?
    let threadTS: String?
    let timestamp: String
}

struct WebhookResponse: Codable {
    let replyText: String
    let channelId: String
    let threadTS: String?
    let status: String
}

struct AIResponse {
    let messageId: String
    let originalResponse: String
    var editedResponse: String?
    let confidenceScore: Double
    let modelUsed: String
    let generationTimeMs: Int
    let autoRuleId: String?
    var status: ResponseStatus = .pending
    var userRating: Int?
    var sentAt: Date?
    
    enum ResponseStatus: String, CaseIterable {
        case pending, approved, edited, rejected, sent, failed
    }
}

struct AutoRule {
    let id: String
    let name: String
    let description: String?
    let triggerKeywords: [String]
    let triggerChannels: [String]
    let triggerUsers: [String]
    let responseTemplate: String
    let confidenceThreshold: Double
    let autoSendEnabled: Bool
    let requireApproval: Bool
    var isActive: Bool
    var usageCount: Int
    var successRate: Double
    var lastUsedAt: Date?
}

struct AnalyticsMetrics {
    var messagesReceived: Int = 0
    var responsesGenerated: Int = 0
    var responsesSent: Int = 0
    var rulesTriggered: Int = 0
    
    var responseRate: Double {
        guard messagesReceived > 0 else { return 0.0 }
        return Double(responsesGenerated) / Double(messagesReceived)
    }
    
    var sendRate: Double {
        guard responsesGenerated > 0 else { return 0.0 }
        return Double(responsesSent) / Double(responsesGenerated)
    }
}
```

---

## Part 2: Zapier Workflow Templates

### 2.1 Primary Workflow: Message Collection

```json
{
  "name": "SlackSassin Message Collector",
  "description": "Collects @mentions and keyword matches from Slack every 15 minutes",
  "trigger": {
    "type": "schedule",
    "app": "Schedule by Zapier",
    "event": "Every X Minutes",
    "config": {
      "interval": 15,
      "timezone": "America/New_York"
    }
  },
  "steps": [
    {
      "id": "slack_search",
      "app": "Slack",
      "action": "Find Message",
      "config": {
        "query": "mentions:@yourusername OR invoice OR urgent OR help OR question",
        "sort": "timestamp",
        "sort_dir": "desc",
        "count": 50
      },
      "notes": "Customize query with your @username and relevant keywords"
    },
    {
      "id": "filter_new",
      "app": "Filter by Zapier",
      "config": {
        "conditions": [
          {
            "field": "{{slack_search.ts}}",
            "operator": "greater_than",
            "value": "{{storage.last_processed_timestamp}}"
          }
        ]
      }
    },
    {
      "id": "format_batch",
      "app": "Formatter by Zapier",
      "action": "Utilities",
      "config": {
        "type": "JSON",
        "data": {
          "messages": [
            {
              "id": "{{slack_search.ts}}-{{slack_search.channel}}",
              "slack_message_id": "{{slack_search.ts}}",
              "slack_user_id": "{{slack_search.user}}",
              "slack_user_name": "{{slack_search.username}}",
              "slack_channel_id": "{{slack_search.channel}}",
              "slack_channel_name": "{{slack_search.channel_name}}",
              "message_text": "{{slack_search.text}}",
              "message_timestamp": "{{slack_search.ts}}",
              "thread_timestamp": "{{slack_search.thread_ts}}",
              "permalink": "{{slack_search.permalink}}",
              "matched_keywords": ["mention"],
              "message_type": "mention"
            }
          ],
          "batch_timestamp": "{{zap_meta_timestamp}}",
          "workspace_id": "{{slack_search.team}}"
        }
      }
    },
    {
      "id":       "send_to_app",
      "app": "Webhooks by Zapier",
      "action": "POST",
      "config": {
        "url": "https://relaxing-sensibly-ghost.ngrok-free.app/zapier-webhook",
        "method": "POST",
        "headers": {
          "Content-Type": "application/json",
          "X-Zapier-Source": "slacksassin-collector"
        },
        "data": "{{format_batch.output}}"
      }
    },
    {
      "id": "update_timestamp",
      "app": "Storage by Zapier",
      "action": "Set Value",
      "config": {
        "key": "last_processed_timestamp",
        "value": "{{zap_meta_timestamp}}"
      }
    }
  ]
}
```

### 2.2 Response Sender Workflow

```json
{
  "name": "SlackSassin Response Sender",
  "description": "Receives approved responses from macOS app and sends to Slack",
  "trigger": {
    "type": "webhook",
    "app": "Webhooks by Zapier",
    "event": "Catch Hook",
    "config": {
      "url": "https://hooks.zapier.com/hooks/catch/YOUR_WEBHOOK_ID/slacksassin-responses/"
    }
  },
  "steps": [
    {
      "id": "validate_payload",
      "app": "Filter by Zapier",
      "config": {
        "conditions": [
          {
            "field": "{{trigger.message_id}}",
            "operator": "exists"
          },
          {
            "field": "{{trigger.response_text}}",
            "operator": "exists"
          },
          {
            "field": "{{trigger.channel}}",
            "operator": "exists"
          }
        ]
      }
    },
    {
      "id": "send_slack_message",
      "app": "Slack",
      "action": "Send Channel Message",
      "config": {
        "channel": "{{trigger.channel}}",
        "text": "{{trigger.response_text}}",
        "thread_ts": "{{trigger.thread_id}}",
        "as_user": false,
        "username": "SlackSassin Bot",
        "icon_emoji": ":robot_face:"
      }
    },
    {
      "id": "log_sent_response",
      "app": "Webhooks by Zapier",
      "action": "POST",
      "config": {
        "url": "https://relaxing-sensibly-ghost.ngrok-free.app/response-confirmation",
        "method": "POST",
        "headers": {
          "Content-Type": "application/json"
        },
        "data": {
          "message_id": "{{trigger.message_id}}",
          "status": "sent",
          "slack_response": {
            "ts": "{{send_slack_message.ts}}",
            "channel": "{{send_slack_message.channel}}",
            "ok": "{{send_slack_message.ok}}"
          },
          "sent_at": "{{zap_meta_timestamp}}"
        }
      }
    }
  ],
  "error_handling": {
    "on_error": "continue",
    "retry_attempts": 3,
    "retry_delay": 300
  }
}
```

### 2.3 Keyword Monitoring Workflow

```json
{
  "name": "SlackSassin Keyword Monitor",
  "description": "Monitors specific channels for important keywords",
  "trigger": {
    "type": "slack_new_message",
    "app": "Slack",
    "event": "New Message Posted to Channel",
    "config": {
      "channel": "#general,#support,#urgent"
    }
  },
  "steps": [
    {
      "id": "keyword_filter",
      "app": "Filter by Zapier",
      "config": {
        "conditions": [
          {
            "field": "{{trigger.text}}",
            "operator": "contains",
            "value": "urgent|emergency|help|invoice|payment|deadline",
            "case_sensitive": false
          }
        ]
      }
    },
    {
      "id": "format_urgent_message",
      "app": "Formatter by Zapier",
      "action": "Utilities",
      "config": {
        "type": "JSON",
        "data": {
          "messages": [
            {
              "id": "{{trigger.ts}}-{{trigger.channel_id}}",
              "slack_message_id": "{{trigger.ts}}",
              "slack_user_id": "{{trigger.user_id}}",
              "slack_user_name": "{{trigger.user_name}}",
              "slack_channel_id": "{{trigger.channel_id}}",
              "slack_channel_name": "{{trigger.channel_name}}",
              "message_text": "{{trigger.text}}",
              "message_timestamp": "{{trigger.ts}}",
              "thread_timestamp": "{{trigger.thread_ts}}",
              "permalink": "{{trigger.permalink}}",
              "matched_keywords": ["urgent"],
              "message_type": "keyword",
              "priority": "high"
            }
          ],
          "batch_timestamp": "{{zap_meta_timestamp}}",
          "workspace_id": "{{trigger.team_id}}"
        }
      }
    },
    {
      "id": "send_urgent_to_app",
      "app": "Webhooks by Zapier",
      "action": "POST",
      "config": {
        "url": "https://relaxing-sensibly-ghost.ngrok-free.app/zapier-webhook",
        "method": "POST",
        "headers": {
          "Content-Type": "application/json",
          "X-Priority": "high"
        },
        "data": "{{format_urgent_message.output}}"
      }
    }
  ]
}
```

### 2.4 Zapier Import Instructions

```bash
# To import these workflows into Zapier:

1. Copy the JSON templates above
2. Log into Zapier.com
3. Click "Create Zap" 
4. Click "Import" in the top right
5. Paste the JSON template
6. Configure your specific settings:
   - Replace "yourusername" with your actual Slack username
   - Update the ngrok URL with your static domain
   - Set your timezone
   - Choose your channels
   - Add your keywords

# Required Zapier Apps (all free):
- Slack (connect your workspace)
- Webhooks by Zapier 
- Schedule by Zapier
- Filter by Zapier
- Formatter by Zapier
- Storage by Zapier

# Estimated monthly usage on Starter plan ($29.99/month):
- Message Collector: 2,880 tasks (15min * 4 times/hour * 24 hours * 30 days)
- Response Sender: ~100 tasks (estimated responses sent)
- Keyword Monitor: ~500 tasks (estimated keyword matches)
Total: ~3,500 tasks/month (well within 750 task limit requires Professional plan)
```

---

## Part 3: Detailed UI Mockups & Implementation

### 3.1 Menu Bar Component

```swift
// MenuBarController.swift - Integrates with your existing app

import Cocoa

class SlackSassinMenuBarController: NSObject {
    private var statusItem: NSStatusItem!
    private var isMenuOpen = false
    
    override init() {
        super.init()
        setupStatusItem()
        observeNotifications()
    }
    
    private func setupStatusItem() {
        statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)
        
        if let button = statusItem.button {
            // Initial icon without badge
            button.image = createMenuBarIcon(badgeCount: 0)
            button.target = self
            button.action = #selector(statusItemClicked(_:))
            button.sendAction(on: [.leftMouseUp, .rightMouseUp])
        }
        
        setupMenu()
    }
    
    private func setupMenu() {
        let menu = NSMenu()
        
        // Dynamic header showing pending count
        let headerItem = NSMenuItem()
        headerItem.view = createHeaderView()
        menu.addItem(headerItem)
        
        menu.addItem(NSMenuItem.separator())
        
        // Quick actions
        menu.addItem(withTitle: "Open SlackSassin", 
                    action: #selector(openMainWindow), 
                    keyEquivalent: "")
        
        menu.addItem(withTitle: "Check for New Messages", 
                    action: #selector(forceSync), 
                    keyEquivalent: "r")
        
        menu.addItem(NSMenuItem.separator())
        
        // Status indicators
        let statusItem = NSMenuItem()
        statusItem.view = createStatusView()
        menu.addItem(statusItem)
        
        menu.addItem(NSMenuItem.separator())
        
        menu.addItem(withTitle: "Settings...", 
                    action: #selector(openSettings), 
                    keyEquivalent: ",")
        
        menu.addItem(withTitle: "Quit SlackSassin", 
                    action: #selector(quitApp), 
                    keyEquivalent: "q")
        
        statusItem.menu = menu
    }
    
    private func createMenuBarIcon(badgeCount: Int) -> NSImage {
        let baseImage = NSImage(systemSymbolName: "message.badge", 
                               accessibilityDescription: "SlackSassin")!
        
        if badgeCount == 0 {
            return baseImage
        }
        
        // Create badged version
        let imageSize = NSSize(width: 22, height: 22)
        let badgedImage = NSImage(size: imageSize)
        
        badgedImage.lockFocus()
        
        // Draw base icon
        baseImage.draw(in: NSRect(origin: .zero, size: imageSize))
        
        // Draw badge
        if badgeCount > 0 {
            let badgeRect = NSRect(x: 12, y: 12, width: 10, height: 10)
            let badgePath = NSBezierPath(ovalIn: badgeRect)
            
            NSColor.systemRed.set()
            badgePath.fill()
            
            // Badge text
            let badgeText = badgeCount > 99 ? "99+" : "\(badgeCount)"
            let textAttributes: [NSAttributedString.Key: Any] = [
                .font: NSFont.systemFont(ofSize: 8),
                .foregroundColor: NSColor.white
            ]
            
            let textSize = badgeText.size(withAttributes: textAttributes)
            let textRect = NSRect(
                x: badgeRect.midX - textSize.width / 2,
                y: badgeRect.midY - textSize.height / 2,
                width: textSize.width,
                height: textSize.height
            )
            
            badgeText.draw(in: textRect, withAttributes: textAttributes)
        }
        
        badgedImage.unlockFocus()
        badgedImage.isTemplate = true
        
        return badgedImage
    }
    
    private func createHeaderView() -> NSView {
        let view = NSView(frame: NSRect(x: 0, y: 0, width: 200, height: 50))
        
        let titleLabel = NSTextField(labelWithString: "SlackSassin")
        titleLabel.font = NSFont.boldSystemFont(ofSize: 14)
        titleLabel.frame = NSRect(x: 10, y: 25, width: 180, height: 20)
        
        let statusLabel = NSTextField(labelWithString: "3 messages pending review")
        statusLabel.font = NSFont.systemFont(ofSize: 11)
        statusLabel.textColor = NSColor.secondaryLabelColor
        statusLabel.frame = NSRect(x: 10, y: 5, width: 180, height: 16)
        
        view.addSubview(titleLabel)
        view.addSubview(statusLabel)
        
        return view
    }
    
    private func createStatusView() -> NSView {
        let view = NSView(frame: NSRect(x: 0, y: 0, width: 200, height: 60))
        
        let indicators = [
            ("Slack", NSColor.systemGreen, "Connected"),
            ("Ngrok", NSColor.systemYellow, "Tunnel Active"),
            ("Ollama", NSColor.systemGreen, "Ready")
        ]
        
        for (index, (name, color, status)) in indicators.enumerated() {
            let y = 40 - (index * 18)
            
            // Status dot
            let dotView = NSView(frame: NSRect(x: 15, y: y + 2, width: 8, height: 8))
            dotView.wantsLayer = true
            dotView.layer?.backgroundColor = color.cgColor
            dotView.layer?.cornerRadius = 4
            
            // Name label
            let nameLabel = NSTextField(labelWithString: name)
            nameLabel.font = NSFont.systemFont(ofSize: 11)
            nameLabel.frame = NSRect(x: 30, y: y, width: 50, height: 14)
            
            // Status label
            let statusLabel = NSTextField(labelWithString: status)
            statusLabel.font = NSFont.systemFont(ofSize: 10)
            statusLabel.textColor = NSColor.secondaryLabelColor
            statusLabel.frame = NSRect(x: 85, y: y, width: 100, height: 14)
            
            view.addSubview(dotView)
            view.addSubview(nameLabel)
            view.addSubview(statusLabel)
        }
        
        return view
    }
    
    @objc private func statusItemClicked(_ sender: AnyObject?) {
        // Menu automatically opens
    }
    
    @objc private func openMainWindow() {
        NotificationCenter.default.post(name: .showMainWindow, object: nil)
    }
    
    @objc private func forceSync() {
        NotificationCenter.default.post(name: .forceSyncMessages, object: nil)
    }
    
    @objc private func openSettings() {
        NotificationCenter.default.post(name: .showSettings, object: nil)
    }
    
    @objc private func quitApp() {
        NSApplication.shared.terminate(nil)
    }
    
    func updateBadgeCount(_ count: Int) {
        statusItem.button?.image = createMenuBarIcon(badgeCount: count)
        // Update menu header
        setupMenu()
    }
    
    private func observeNotifications() {
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(messagesUpdated(_:)),
            name: .pendingMessagesCountChanged,
            object: nil
        )
    }
    
    @objc private func messagesUpdated(_ notification: Notification) {
        if let count = notification.object as? Int {
            updateBadgeCount(count)
        }
    }
}

// Notification names
extension Notification.Name {
    static let showMainWindow = Notification.Name("showMainWindow")
    static let forceSyncMessages = Notification.Name("forceSyncMessages")
    static let showSettings = Notification.Name("showSettings")
    static let pendingMessagesCountChanged = Notification.Name("pendingMessagesCountChanged")
}
```

### 3.2 Main Window Layout Implementation

```swift
// MainWindowController.swift

import Cocoa

class SlackSassinMainWindowController: NSWindowController {
    
    override func windowDidLoad() {
        super.windowDidLoad()
        setupWindow()
        setupSplitViewController()
    }
    
    private func setupWindow() {
        guard let window = window else { return }
        
        window.title = "SlackSassin"
        window.setContentSize(NSSize(width: 1200, height: 800))
        window.minSize = NSSize(width: 900, height: 600)
        window.center()
        
        // Modern macOS window styling
        window.titleVisibility = .hidden
        window.titlebarAppearsTransparent = true
        window.styleMask.insert(.fullSizeContentView)
        
        // Toolbar
        let toolbar = NSToolbar(identifier: "MainToolbar")
        toolbar.delegate = self
        toolbar.displayMode = .iconAndLabel
        window.toolbar = toolbar
    }
    
    private func setupSplitViewController() {
        let splitViewController = SlackSassinSplitViewController()
        contentViewController = splitViewController
    }
}

// MARK: - Toolbar Delegate
extension SlackSassinMainWindowController: NSToolbarDelegate {
    func toolbar(_ toolbar: NSToolbar, itemForItemIdentifier itemIdentifier: NSToolbarItem.Identifier, willBeInsertedIntoToolbar flag: Bool) -> NSToolbarItem? {
        
        switch itemIdentifier {
        case .flexibleSpace:
            return NSToolbarItem(itemIdentifier: .flexibleSpace)
            
        case .refresh:
            let item = NSToolbarItem(itemIdentifier: .refresh)
            item.label = "Refresh"
            item.paletteLabel = "Refresh Messages"
            item.image = NSImage(systemSymbolName: "arrow.clockwise", accessibilityDescription: "Refresh")
            item.target = self
            item.action = #selector(refreshMessages)
            return item
            
        case .settings:
            let item = NSToolbarItem(itemIdentifier: .settings)
            item.label = "Settings"
            item.paletteLabel = "Settings"
            item.image = NSImage(systemSymbolName: "gear", accessibilityDescription: "Settings")
            item.target = self
            item.action = #selector(showSettings)
            return item
            
        default:
            return nil
        }
    }
    
    func toolbarDefaultItemIdentifiers(_ toolbar: NSToolbar) -> [NSToolbarItem.Identifier] {
        return [.refresh, .flexibleSpace, .settings]
    }
    
    func toolbarAllowedItemIdentifiers(_ toolbar: NSToolbar) -> [NSToolbarItem.Identifier] {
        return [.refresh, .settings, .flexibleSpace]
    }
    
    @objc private func refreshMessages() {
        NotificationCenter.default.post(name: .forceSyncMessages, object: nil)
    }
    
    @objc private func showSettings() {
        NotificationCenter.default.post(name: .showSettings, object: nil)
    }
}

extension NSToolbarItem.Identifier {
    static let refresh = NSToolbarItem.Identifier("refresh")
    static let settings = NSToolbarItem.Identifier("settings")
}
```

### 3.3 Split View Controller with Sidebar

```swift
// SlackSassinSplitViewController.swift

import Cocoa

class SlackSassinSplitViewController: NSSplitViewController {
    
    private var sidebarViewController: SidebarViewController!
    private var contentViewController: ContentViewController!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupSplitView()
    }
    
    private func setupSplitView() {
        // Sidebar
        sidebarViewController = SidebarViewController()
        let sidebarItem = NSSplitViewItem(sidebarWithViewController: sidebarViewController)
        sidebarItem.minimumThickness = 220
        sidebarItem.maximumThickness = 300
        sidebarItem.canCollapse = true
        
        // Content area
        contentViewController = ContentViewController()
        let contentItem = NSSplitViewItem(viewController: contentViewController)
        contentItem.minimumThickness = 400
        
        addSplitViewItem(sidebarItem)
        addSplitViewItem(contentItem)
        
        // Connect sidebar selection to content
        sidebarViewController.selectionDelegate = contentViewController
    }
}

// MARK: - Sidebar Implementation
class SidebarViewController: NSViewController {
    
    @IBOutlet weak var outlineView: NSOutlineView!
    
    weak var selectionDelegate: SidebarSelectionDelegate?
    
    private var sidebarItems: [SidebarItem] = []
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupSidebar()
        loadSidebarItems()
    }
    
    private func setupSidebar() {
        outlineView.dataSource = self
        outlineView.delegate = self
        outlineView.selectionHighlightStyle = .sourceList
        
        // Custom cell registration
        let cellNib = NSNib(nibNamed: "SidebarCellView", bundle: nil)
        outlineView.register(cellNib, forIdentifier: .sidebarCell)
    }
    
    private func loadSidebarItems() {
        sidebarItems = [
            SidebarItem(title: "Inbox", 
                       icon: "tray", 
                       type: .inbox, 
                       badgeCount: 5),
            SidebarItem(title: "History", 
                       icon: "clock.arrow.circlepath", 
                       type: .history),
            SidebarItem(title: "Analytics", 
                       icon: "chart.line.uptrend.xyaxis", 
                       type: .analytics),
            SidebarItem(title: "Templates & Rules", 
                       icon: "doc.text.below.ecg", 
                       type: .rules),
            SidebarItem(title: "Settings", 
                       icon: "gear", 
                       type: .settings)
        ]
        
        outlineView.reloadData()
        
        // Select inbox by default
        outlineView.selectRowIndexes(IndexSet(integer: 0), byExtendingSelection: false)
        selectionDelegate?.sidebarDidSelectItem(.inbox)
    }
}

// MARK: - Outline View Data Source & Delegate
extension SidebarViewController: NSOutlineViewDataSource, NSOutlineViewDelegate {
    
    func outlineView(_ outlineView: NSOutlineView, numberOfChildrenOfItem item: Any?) -> Int {
        return item == nil ? sidebarItems.count : 0
    }
    
    func outlineView(_ outlineView: NSOutlineView, child index: Int, ofItem item: Any?) -> Any {
        return sidebarItems[index]
    }
    
    func outlineView(_ outlineView: NSOutlineView, isItemExpandable item: Any) -> Bool {
        return false
    }
    
    func outlineView(_ outlineView: NSOutlineView, viewFor tableColumn: NSTableColumn?, item: Any) -> NSView? {
        guard let sidebarItem = item as? SidebarItem else { return nil }
        
        let cellView = outlineView.makeView(withIdentifier: .sidebarCell, owner: nil) as! SidebarCellView
        cellView.configure(with: sidebarItem)
        
        return cellView
    }
    
    func outlineViewSelectionDidChange(_ notification: Notification) {
        let selectedRow = outlineView.selectedRow
        guard selectedRow >= 0, selectedRow < sidebarItems.count else { return }
        
        let selectedItem = sidebarItems[selectedRow]
        selectionDelegate?.sidebarDidSelectItem(selectedItem.type)
    }
}

// MARK: - Sidebar Models
struct SidebarItem {
    let title: String
    let icon: String
    let type: SidebarItemType
    var badgeCount: Int = 0
}

enum SidebarItemType {
    case inbox, history, analytics, rules, settings
}

protocol SidebarSelectionDelegate: AnyObject {
    func sidebarDidSelectItem(_ itemType: SidebarItemType)
}

extension NSUserInterfaceItemIdentifier {
    static let sidebarCell = NSUserInterfaceItemIdentifier("SidebarCellView")
}
```

### 3.4 Sidebar Cell View

```swift
// SidebarCellView.swift

import Cocoa

class SidebarCellView: NSTableCellView {
    
    @IBOutlet weak var iconImageView: NSImageView!
    @IBOutlet weak var titleLabel: NSTextField!
    @IBOutlet weak var badgeLabel: NSTextField!
    @IBOutlet weak var badgeBackground: NSView!
    
    override func awakeFromNib() {
        super.awakeFromNib()
        setupBadge()
    }
    
    private func setupBadge() {
        badgeBackground.wantsLayer = true
        badgeBackground.layer?.backgroundColor = NSColor.systemRed.cgColor
        badgeBackground.layer?.cornerRadius = 10
        badgeBackground.isHidden = true
        
        badgeLabel.textColor = .white
        badgeLabel.font = NSFont.boldSystemFont(ofSize: 11)
    }
    
    func configure(with item: SidebarItem) {
        iconImageView.image = NSImage(systemSymbolName: item.icon, 
                                     accessibilityDescription: item.title)
        titleLabel.stringValue = item.title
        
        if item.badgeCount > 0 {
            badgeLabel.stringValue = "\(item.badgeCount)"
            badgeBackground.isHidden = false
        } else {
            badgeBackground.isHidden = true
        }
    }
}
```

### 3.5 Content View Controller with Tab Management

```swift
// ContentViewController.swift

import Cocoa

class ContentViewController: NSViewController, SidebarSelectionDelegate {
    
    private var currentViewController: NSViewController?
    private var viewControllers: [SidebarItemType: NSViewController] = [:]
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupViewControllers()
    }
    
    private func setupViewControllers() {
        viewControllers = [
            .inbox: InboxViewController(),
            .history: HistoryViewController(),
            .analytics: AnalyticsViewController(),
            .rules: RulesViewController(),
            .settings: SettingsViewController()
        ]
    }
    
    func sidebarDidSelectItem(_ itemType: SidebarItemType) {
        // Remove current view controller
        currentViewController?.view.removeFromSuperview()
        currentViewController?.removeFromParent()
        
        // Add new view controller
        guard let newViewController = viewControllers[itemType] else { return }
        
        addChild(newViewController)
        view.addSubview(newViewController.view)
        newViewController.view.frame = view.bounds
        newViewController.view.autoresizingMask = [.width, .height]
        
        currentViewController = newViewController
    }
}
```

### 3.6 Inbox View Controller with Message List

```swift
// InboxViewController.swift

import Cocoa

class InboxViewController: NSViewController {
    
    @IBOutlet weak var splitView: NSSplitView!
    @IBOutlet weak var tableView: NSTableView!
    @IBOutlet weak var messageDetailContainer: NSView!
    
    private var messages: [MessageWithResponse] = []
    private var detailViewController: MessageDetailViewController?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupTableView()
        setupDetailView()
        loadMessages()
    }
    
    private func setupTableView() {
        tableView.dataSource = self
        tableView.delegate = self
        
        // Custom cell
        let cellNib = NSNib(nibNamed: "MessageTableCellView", bundle: nil)
        tableView.register(cellNib, forIdentifier: .messageCell)
        
        // Table styling
        tableView.selectionHighlightStyle = .regular
        tableView.allowsEmptySelection = false
    }
    
    private func setupDetailView() {
        detailViewController = MessageDetailViewController()
        guard let detailVC = detailViewController else { return }
        
        addChild(detailVC)
        messageDetailContainer.addSubview(detailVC.view)
        detailVC.view.frame = messageDetailContainer.bounds
        detailVC.view.autoresizingMask = [.width, .height]
    }
    
    private func loadMessages() {
        // Load from database
        let pendingMessages = SlackSassinDatabase.shared.getPendingMessages()
        messages = pendingMessages.map { message in
            let response = SlackSassinDatabase.shared.getAIResponse(for: message.id)
            return MessageWithResponse(message: message, aiResponse: response)
        }
        
        tableView.reloadData()
        
        // Select first message
        if !messages.isEmpty {
            tableView.selectRowIndexes(IndexSet(integer: 0), byExtendingSelection: false)
            showMessageDetail(at: 0)
        }
    }
    
    private func showMessageDetail(at index: Int) {
        guard index < messages.count else { return }
        let messageWithResponse = messages[index]
        detailViewController?.display(messageWithResponse)
    }
}

// MARK: - Table View Data Source & Delegate
extension InboxViewController: NSTableViewDataSource, NSTableViewDelegate {
    
    func numberOfRows(in tableView: NSTableView) -> Int {
        return messages.count
    }
    
    func tableView(_ tableView: NSTableView, viewFor tableColumn: NSTableColumn?, row: Int) -> NSView? {
        let cellView = tableView.makeView(withIdentifier: .messageCell, owner: nil) as! MessageTableCellView
        let messageWithResponse = messages[row]
        cellView.configure(with: messageWithResponse)
        return cellView
    }
    
    func tableViewSelectionDidChange(_ notification: Notification) {
        let selectedRow = tableView.selectedRow
        if selectedRow >= 0 {
            showMessageDetail(at: selectedRow)
        }
    }
}

extension NSUserInterfaceItemIdentifier {
    static let messageCell = NSUserInterfaceItemIdentifier("MessageTableCellView")
}

struct MessageWithResponse {
    let message: SlackMessage
    let aiResponse: AIResponse?
}
```

### 3.7 Message Table Cell View

```swift
// MessageTableCellView.swift

import Cocoa

class MessageTableCellView: NSTableCellView {
    
    @IBOutlet weak var userAvatarView: NSImageView!
    @IBOutlet weak var userNameLabel: NSTextField!
    @IBOutlet weak var channelLabel: NSTextField!
    @IBOutlet weak var messagePreviewLabel: NSTextField!
    @IBOutlet weak var timestampLabel: NSTextField!
    @IBOutlet weak var statusIndicator: NSImageView!
    @IBOutlet weak var aiIndicator: NSImageView!
    @IBOutlet weak var priorityIndicator: NSView!
    
    override func awakeFromNib() {
        super.awakeFromNib()
        setupUI()
    }
    
    private func setupUI() {
        userAvatarView.wantsLayer = true
        userAvatarView.layer?.cornerRadius = 16
        userAvatarView.layer?.masksToBounds = true
        
        priorityIndicator.wantsLayer = true
        priorityIndicator.layer?.cornerRadius = 3
        priorityIndicator.isHidden = true
    }
    
    func configure(with messageWithResponse: MessageWithResponse) {
        let message = messageWithResponse.message
        let response = messageWithResponse.aiResponse
        
        // User info
        userNameLabel.stringValue = message.slackUserName
        channelLabel.stringValue = "#\(message.slackChannelName)"
        
        // Message preview (truncated)
        let preview = String(message.messageText.prefix(100))
        messagePreviewLabel.stringValue = preview + (message.messageText.count > 100 ? "..." : "")
        
        // Timestamp
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        timestampLabel.stringValue = formatter.localizedString(for: message.messageTimestamp, relativeTo: Date())
        
        // Status indicator
        switch response?.status {
        case .pending, .none:
            statusIndicator.image = NSImage(systemSymbolName: "clock", 
                                          accessibilityDescription: "Pending")
            statusIndicator.contentTintColor = .systemYellow
        case .approved:
            statusIndicator.image = NSImage(systemSymbolName: "checkmark.circle", 
                                          accessibilityDescription: "Approved")
            statusIndicator.contentTintColor = .systemGreen
        case .edited:
            statusIndicator.image = NSImage(systemSymbolName: "pencil.circle", 
                                          accessibilityDescription: "Edited")
            statusIndicator.contentTintColor = .systemBlue
        case .sent:
            statusIndicator.image = NSImage(systemSymbolName: "checkmark.circle.fill", 
                                          accessibilityDescription: "Sent")
            statusIndicator.contentTintColor = .systemGreen
        case .rejected:
            statusIndicator.image = NSImage(systemSymbolName: "xmark.circle", 
                                          accessibilityDescription: "Rejected")
            statusIndicator.contentTintColor = .systemRed
        case .failed:
            statusIndicator.image = NSImage(systemSymbolName: "exclamationmark.triangle", 
                                          accessibilityDescription: "Failed")
            statusIndicator.contentTintColor = .systemOrange
        }
        
        // AI indicator
        if response != nil {
            aiIndicator.image = NSImage(systemSymbolName: "brain", 
                                      accessibilityDescription: "AI Response Available")
            aiIndicator.contentTintColor = .systemPurple
            aiIndicator.isHidden = false
        } else {
            aiIndicator.isHidden = true
        }
        
        // Priority indicator for urgent messages
        if message.matchedKeywords.contains(where: { ["urgent", "emergency", "help"].contains($0.lowercased()) }) {
            priorityIndicator.layer?.backgroundColor = NSColor.systemRed.cgColor
            priorityIndicator.isHidden = false
        } else {
            priorityIndicator.isHidden = true
        }
        
        // User avatar (placeholder for now)
        userAvatarView.image = NSImage(systemSymbolName: "person.circle.fill", 
                                     accessibilityDescription: "User Avatar")
        userAvatarView.contentTintColor = .systemBlue
    }
}
```

### 3.8 Message Detail View with Rich Editor

```swift
// MessageDetailViewController.swift

import Cocoa

class MessageDetailViewController: NSViewController {
    
    @IBOutlet weak var originalMessageContainer: NSView!
    @IBOutlet weak var aiSuggestionContainer: NSView!
    @IBOutlet weak var editingContainer: NSView!
    @IBOutlet weak var buttonContainer: NSView!
    
    @IBOutlet weak var originalMessageTextView: NSTextView!
    @IBOutlet weak var aiSuggestionTextView: NSTextView!
    @IBOutlet weak var editableTextView: NSTextView!
    
    @IBOutlet weak var sendNowButton: NSButton!
    @IBOutlet weak var editAndSendButton: NSButton!
    @IBOutlet weak var rejectButton: NSButton!
    @IBOutlet weak var autoRuleButton: NSButton!
    
    @IBOutlet weak var confidenceLabel: NSTextField!
    @IBOutlet weak var confidenceProgressIndicator: NSProgressIndicator!
    
    private var currentMessage: MessageWithResponse?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupTextViews()
        setupButtons()
    }
    
    private func setupTextViews() {
        // Original message (read-only)
        originalMessageTextView.isEditable = false
        originalMessageTextView.isSelectable = true
        originalMessageTextView.font = NSFont.systemFont(ofSize: 14)
        
        // AI suggestion (read-only)
        aiSuggestionTextView.isEditable = false
        aiSuggestionTextView.isSelectable = true
        aiSuggestionTextView.font = NSFont.systemFont(ofSize: 14)
        aiSuggestionTextView.backgroundColor = NSColor.controlBackgroundColor
        
        // Editable response
        editableTextView.isEditable = true
        editableTextView.isSelectable = true
        editableTextView.font = NSFont.systemFont(ofSize: 14)
        editableTextView.delegate = self
        
        // Add Slack formatting support
        setupSlackFormatting()
    }
    
    private func setupButtons() {
        sendNowButton.title = "Send Now"
        sendNowButton.bezelStyle = .rounded
        sendNowButton.keyEquivalent = "\r"
        
        editAndSendButton.title = "Edit & Send"
        editAndSendButton.bezelStyle = .rounded
        
        rejectButton.title = "Reject"
        rejectButton.bezelStyle = .rounded
        
        autoRuleButton.title = "Create Auto-Rule"
        autoRuleButton.bezelStyle = .rounded
    }
    
    private func setupSlackFormatting() {
        // Add formatting toolbar
        let toolbar = NSToolbar(identifier: "FormattingToolbar")
        toolbar.displayMode = .iconOnly
        toolbar.sizeMode = .small
        
        // Custom formatting buttons for Slack markdown
        // Implementation details...
    }
    
    func display(_ messageWithResponse: MessageWithResponse) {
        currentMessage = messageWithResponse
        
        let message = messageWithResponse.message
        let response = messageWithResponse.aiResponse
        
        // Display original message with rich formatting
        let originalText = formatSlackMessage(message.messageText, 
                                            user: message.slackUserName, 
                                            channel: message.slackChannelName, 
                                            timestamp: message.messageTimestamp)
        originalMessageTextView.textStorage?.setAttributedString(originalText)
        
        // Display AI suggestion
        if let response = response {
            let suggestionText = NSAttributedString(
                string: response.originalResponse,
                attributes: [
                    .font: NSFont.systemFont(ofSize: 14),
                    .foregroundColor: NSColor.textColor
                ]
            )
            aiSuggestionTextView.textStorage?.setAttributedString(suggestionText)
            
            // Pre-populate editor with AI response or edited version
            let editText = response.editedResponse ?? response.originalResponse
            editableTextView.string = editText
            
            // Show confidence
            confidenceLabel.stringValue = "Confidence: \(Int(response.confidenceScore * 100))%"
            confidenceProgressIndicator.doubleValue = response.confidenceScore
            
            updateButtonStates(for: response.status)
        } else {
            // No AI response yet
            aiSuggestionTextView.string = "Generating AI response..."
            editableTextView.string = ""
            confidenceLabel.stringValue = "Processing..."
            confidenceProgressIndicator.doubleValue = 0
            
            disableAllButtons()
        }
    }
    
    private func formatSlackMessage(_ text: String, user: String, channel: String, timestamp: Date) -> NSAttributedString {
        let attributed = NSMutableAttributedString()
        
        // Header with user and channel info
        let header = NSAttributedString(
            string: "@\(user) in #\(channel)\n",
            attributes: [
                .font: NSFont.boldSystemFont(ofSize: 12),
                .foregroundColor: NSColor.secondaryLabelColor
            ]
        )
        attributed.append(header)
        
        // Timestamp
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .short
        let timeString = formatter.string(from: timestamp)
        
        let timestampAttr = NSAttributedString(
            string: timeString + "\n\n",
            attributes: [
                .font: NSFont.systemFont(ofSize: 11),
                .foregroundColor: NSColor.tertiaryLabelColor
            ]
        )
        attributed.append(timestampAttr)
        
        // Message text with Slack formatting
        let messageAttr = applySlackFormatting(to: text)
        attributed.append(messageAttr)
        
        return attributed
    }
    
    private func applySlackFormatting(to text: String) -> NSAttributedString {
        let attributed = NSMutableAttributedString(string: text)
        
        // Apply Slack markdown formatting
        // *bold*, _italic_, `code`, etc.
        
        // Bold pattern: *text*
        let boldRegex = try! NSRegularExpression(pattern: "\\*([^*]+)\\*", options: [])
        let boldMatches = boldRegex.matches(in: text, options: [], range: NSRange(location: 0, length: text.count))
        
        for match in boldMatches.reversed() {
            let range = match.range(at: 1)
            attributed.addAttribute(.font, value: NSFont.boldSystemFont(ofSize: 14), range: range)
            
            // Remove markdown characters
            attributed.deleteCharacters(in: NSRange(location: match.range.location + match.range.length - 1, length: 1))
            attributed.deleteCharacters(in: NSRange(location: match.range.location, length: 1))
        }
        
        // Similar patterns for italic, code, etc.
        
        return attributed
    }
    
    private func updateButtonStates(for status: AIResponse.ResponseStatus) {
        switch status {
        case .pending:
            sendNowButton.isEnabled = true
            editAndSendButton.isEnabled = true
            rejectButton.isEnabled = true
            autoRuleButton.isEnabled = true
            
        case .approved, .edited:
            sendNowButton.isEnabled = false
            editAndSendButton.isEnabled = false
            rejectButton.isEnabled = false
            autoRuleButton.isEnabled = true
            
        case .sent:
            disableAllButtons()
            
        case .rejected, .failed:
            sendNowButton.isEnabled = false
            editAndSendButton.isEnabled = false
            rejectButton.isEnabled = false
            autoRuleButton.isEnabled = true
        }
    }
    
    private func disableAllButtons() {
        sendNowButton.isEnabled = false
        editAndSendButton.isEnabled = false
        rejectButton.isEnabled = false
        autoRuleButton.isEnabled = false
    }
    
    // MARK: - Button Actions
    
    @IBAction func sendNow(_ sender: NSButton) {
        guard let messageWithResponse = currentMessage,
              let response = messageWithResponse.aiResponse else { return }
        
        sendResponse(response)
    }
    
    @IBAction func editAndSend(_ sender: NSButton) {
        guard let messageWithResponse = currentMessage,
              var response = messageWithResponse.aiResponse else { return }
        
        // Update response with edited text
        response.editedResponse = editableTextView.string
        response.status = .edited
        
        // Save to database
        SlackSassinDatabase.shared.updateAIResponse(response)
        
        sendResponse(response)
    }
    
    @IBAction func reject(_ sender: NSButton) {
        guard let messageWithResponse = currentMessage,
              var response = messageWithResponse.aiResponse else { return }
        
        response.status = .rejected
        SlackSassinDatabase.shared.updateAIResponse(response)
        
        updateButtonStates(for: .rejected)
        
        // Move to next message
        NotificationCenter.default.post(name: .moveToNextMessage, object: nil)
    }
    
    @IBAction func createAutoRule(_ sender: NSButton) {
        // Present auto-rule creation sheet
        presentAutoRuleCreation()
    }
    
    private func sendResponse(_ response: AIResponse) {
        // Send via webhook to Zapier
        ResponseSender.shared.sendResponse(response) { [weak self] success in
            DispatchQueue.main.async {
                if success {
                    var updatedResponse = response
                    updatedResponse.status = .sent
                    updatedResponse.sentAt = Date()
                    SlackSassinDatabase.shared.updateAIResponse(updatedResponse)
                    
                    self?.updateButtonStates(for: .sent)
                    
                    // Move to next message
                    NotificationCenter.default.post(name: .moveToNextMessage, object: nil)
                } else {
                    // Handle send failure
                    self?.showSendError()
                }
            }
        }
    }
    
    private func presentAutoRuleCreation() {
        let storyboard = NSStoryboard(name: "AutoRule", bundle: nil)
        let autoRuleVC = storyboard.instantiateController(withIdentifier: "AutoRuleCreationViewController") as! AutoRuleCreationViewController
        
        if let messageWithResponse = currentMessage {
            autoRuleVC.prepopulate(with: messageWithResponse)
        }
        
        presentAsSheet(autoRuleVC)
    }
    
    private func showSendError() {
        let alert = NSAlert()
        alert.messageText = "Failed to Send Response"
        alert.informativeText = "The response could not be sent to Slack. Please check your connection and try again."
        alert.addButton(withTitle: "OK")
        alert.addButton(withTitle: "Retry")
        
        alert.beginSheetModal(for: view.window!) { response in
            if response == .alertSecondButtonReturn {
                // Retry sending
                if let currentResponse = self.currentMessage?.aiResponse {
                    self.sendResponse(currentResponse)
                }
            }
        }
    }
}

// MARK: - Text View Delegate
extension MessageDetailViewController: NSTextViewDelegate {
    func textDidChange(_ notification: Notification) {
        // Enable edit and send button when text is modified
        editAndSendButton.isEnabled = true
        
        // Auto-save draft
        // Implementation...
    }
}

extension Notification.Name {
    static let moveToNextMessage = Notification.Name("moveToNextMessage")
}
```

---

## Part 4: Integration Points & Implementation Notes

### 4.1 Webhook Endpoint Handler

```swift
// SlackerWebhookServer.swift - Add to your existing Slacker app
// Uses Swifter HTTP server library for macOS compatibility

import Foundation
import Swifter

class SlackerWebhookServer: ObservableObject {
    private let server = HttpServer()
    private let port: UInt16 = 8080
    
    @Published var isRunning: Bool = false
    @Published var lastError: String?
    
    func startServer() {
        setupRoutes()
        
        do {
            try server.start(port, forceIPv4: true)
            isRunning = true
            lastError = nil
            print("Slacker webhook server started on port \(port)")
            print("NGrok URL: https://relaxing-sensibly-ghost.ngrok-free.app")
        } catch {
            isRunning = false
            lastError = error.localizedDescription
            print("Failed to start webhook server: \(error)")
        }
    }
    
    func stopServer() {
        server.stop()
        isRunning = false
        print("Slacker webhook server stopped")
    }
    
    private func setupRoutes() {
        // Primary webhook endpoint for Zapier
        server["/zapier-webhook"] = { request in
            return self.handleZapierWebhook(request)
        }
        
        // Health check endpoint
        server["/health"] = { _ in
            return .ok(.json([
                "status": "healthy",
                "timestamp": Date().timeIntervalSince1970,
                "port": self.port
            ]))
        }
        
        // Server status endpoint
        server["/status"] = { _ in
            return .ok(.json([
                "server": "running",
                "version": "1.0.0",
                "ngrok_url": "https://relaxing-sensibly-ghost.ngrok-free.app"
            ]))
        }
        
        // Response confirmation endpoint
        server["/response-confirmation"] = { request in
            return self.handleResponseConfirmation(request)
        }
    }
    
    private func handleZapierWebhook(_ request: HttpRequest) -> HttpResponse {
        guard request.method == "POST" else {
            return .badRequest(.text("Only POST method allowed"))
        }
        
        // Parse JSON payload from Zapier
        guard let bodyData = Data(request.body),
              let zapierPayload = try? JSONDecoder().decode(ZapierPayload.self, from: bodyData) else {
            print("Invalid JSON payload received")
            return .badRequest(.text("Invalid JSON payload"))
        }
        
        // Create SlackMessage from Zapier payload
        let message = SlackMessage(from: zapierPayload)
        
        // Save to database
        if SlackSassinDatabase.shared.insertMessage(message) {
            print("Message saved: \(message.messageText)")
            
            // Queue for AI processing
            MessageProcessor.shared.queueMessage(message)
            
            // Update UI on main thread
            DispatchQueue.main.async {
                NotificationCenter.default.post(name: .newMessageReceived, object: message)
            }
            
            return .ok(.json([
                "status": "received",
                "message_id": message.id,
                "timestamp": Date().timeIntervalSince1970
            ]))
        } else {
            print("Failed to save message to database")
            return .internalServerError(.text("Failed to save message"))
        }
    }
    
    private func handleResponseConfirmation(_ request: HttpRequest) -> HttpResponse {
        guard request.method == "POST" else {
            return .badRequest(.text("Only POST method allowed"))
        }
        
        // Handle response confirmation from Zapier after sending to Slack
        guard let bodyData = Data(request.body),
              let confirmation = try? JSONSerialization.jsonObject(with: bodyData) as? [String: Any],
              let messageId = confirmation["message_id"] as? String,
              let status = confirmation["status"] as? String else {
            return .badRequest(.text("Invalid confirmation payload"))
        }
        
        // Update message status in database
        if status == "sent" {
            SlackSassinDatabase.shared.updateMessageStatus(messageId, status: .sent)
            print("Message \(messageId) marked as sent")
        } else {
            SlackSassinDatabase.shared.updateMessageStatus(messageId, status: .error)
            print("Message \(messageId) failed to send")
        }
        
        // Update UI
        DispatchQueue.main.async {
            NotificationCenter.default.post(name: .messageStatusUpdated, object: messageId)
        }
        
        return .ok(.text("OK"))
    }
}

struct SlackBatchRequest: Codable {
    let messages: [SlackMessageData]
    let batchTimestamp: Date
    let workspaceId: String
}

struct SlackMessageData: Codable {
    let id: String
    let slackMessageId: String
    let slackUserId: String
    let slackUserName: String
    let slackChannelId: String
    let slackChannelName: String
    let messageText: String
    let messageTimestamp: Date
    let threadTimestamp: String?
    let permalink: String?
    let matchedKeywords: [String]
    let messageType: String
}
```

### 4.2 Response Sender Implementation

```swift
// ResponseSender.swift

import Foundation

class ResponseSender {
    static let shared = ResponseSender()
    private let zapierWebhookURL: String
    
    private init() {
        // Get webhook URL from settings
        zapierWebhookURL = SlackSassinDatabase.shared.getSetting(key: "zapier_response_webhook") ?? ""
    }
    
    func sendResponse(_ response: AIResponse, completion: @escaping (Bool) -> Void) {
        guard !zapierWebhookURL.isEmpty else {
            print("Zapier webhook URL not configured")
            completion(false)
            return
        }
        
        guard let message = SlackSassinDatabase.shared.getMessage(id: response.messageId) else {
            print("Message not found for response")
            completion(false)
            return
        }
        
        let payload = ZapierResponsePayload(
            messageId: response.messageId,
            responseText: response.editedResponse ?? response.originalResponse,
            channel: message.slackChannelId,
            threadId: message.threadTimestamp,
            originalMessageText: message.messageText,
            userIdMention: message.slackUserId
        )
        
        guard let url = URL(string: zapierWebhookURL),
              let jsonData = try? JSONEncoder().encode(payload) else {
            completion(false)
            return
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = jsonData
        
        URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("Failed to send response: \(error)")
                completion(false)
                return
            }
            
            if let httpResponse = response as? HTTPURLResponse,
               200...299 ~= httpResponse.statusCode {
                print("Response sent successfully")
                completion(true)
            } else {
                print("Server returned error")
                completion(false)
            }
        }.resume()
    }
}

struct ZapierResponsePayload: Codable {
    let messageId: String
    let responseText: String
    let channel: String
    let threadId: String?
    let originalMessageText: String
    let userIdMention: String
    let timestamp: Date = Date()
}
```

---

## Implementation Timeline & Development Phases

### Phase 1 (Week 1-2): Foundation & Core Integration
**Goal**: Basic webhook reception and database setup
- [ ] Set up database schema using the provided SQLite setup
- [ ] Implement `SlackerWebhookServer` with Swifter HTTP server
- [ ] Add `/zapier-webhook` endpoint for message reception
- [ ] Configure NGrok tunnel: `ngrok http --url=relaxing-sensibly-ghost.ngrok-free.app 8080`
- [ ] Test webhook reception from Zapier with sample payloads
- [ ] Implement basic `SlackMessage` model and database operations

### Phase 2 (Week 3-4): Core UI & Navigation
**Goal**: SlackOffView primary interface with basic message display
- [ ] Create `SlackOffView` as new primary interface
- [ ] Implement navigation between `SlackOffView` and existing `ChatView`
- [ ] Build webhook server status indicators
- [ ] Create message queue display with basic actions
- [ ] Add "Chat with SlackSassin" navigation button
- [ ] Implement message status tracking (pending, processing, completed)

### Phase 3 (Week 5-6): AI Integration & Response Management
**Goal**: Ollama processing and response workflow
- [ ] Integrate webhook messages with existing Ollama chat functionality
- [ ] Implement AI response generation pipeline
- [ ] Add response editing with "Edit in Chat" functionality
- [ ] Build response sending pipeline back to Zapier/Slack via webhooks
- [ ] Implement copy, send, dismiss actions
- [ ] Add error handling and retry mechanisms

### Phase 4 (Week 7-8): Advanced Features & Polish
**Goal**: Auto-rules, analytics, and comprehensive workflow
- [ ] Implement auto-rules engine for pattern learning
- [ ] Build analytics dashboard with message/response metrics
- [ ] Add comprehensive settings and configuration UI
- [ ] Enhance menu bar integration with badge notifications
- [ ] Implement message templates and bulk operations
- [ ] Comprehensive testing and user experience refinement

### Deployment & Testing Checklist
1. **NGrok Setup**: `ngrok http --url=relaxing-sensibly-ghost.ngrok-free.app 8080`
2. **Zapier Configuration**: Webhook URL → `https://relaxing-sensibly-ghost.ngrok-free.app/zapier-webhook`
3. **Server Verification**: Test `/health` and `/status` endpoints
4. **End-to-End Testing**: Slack → Zapier → Slacker → Ollama → Response → Zapier → Slack
5. **Error Scenarios**: Network failures, Ollama downtime, invalid payloads

## Summary & Integration Notes

This comprehensive implementation plan has been updated to integrate with your existing **Slacker** macOS app architecture. Key integration points:

### **Architecture Alignment**
- **Primary Interface**: SlackOffView becomes the main interface for Slack message processing
- **Secondary Interface**: Your existing ChatView remains available via "Chat with SlackSassin" button
- **Webhook Infrastructure**: Uses your specified NGrok URL (`https://relaxing-sensibly-ghost.ngrok-free.app/`)
- **Development Approach**: Follows 4-phase implementation aligned with your current app structure

### **Technical Integration** 
- **Database**: SQLite integration with your existing SwiftData setup
- **HTTP Server**: Swifter library for macOS compatibility (lightweight alternative to complex server frameworks)
- **AI Processing**: Leverages your existing Ollama integration and chat infrastructure
- **Navigation**: Seamless flow between reactive message processing and interactive chat modes

### **Key Benefits**
- **Builds on Existing Foundation**: Enhances your current Slacker app rather than replacing it
- **Preserves Current Functionality**: ChatView remains fully functional for traditional AI chat
- **Adds Slack Integration**: New SlackOffView handles incoming Slack messages via webhooks
- **Unified Experience**: One app for both reactive Slack assistance and proactive AI chat

The batch-processing approach eliminates complex Slack API integration while delivering the "cognitive burden reduction" that makes this tool valuable for managing Slack communications efficiently.

**Next Steps**: We'll start with Phase 1 (Foundation & Core Integration) to establish the webhook server and basic message reception, then progressively build the UI and AI integration features.